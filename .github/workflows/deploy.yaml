# =============================================================================
# CI/CD ‚Äì Build de API y Worker ‚Üí GHCR + Deploy por SSH con docker compose
# =============================================================================
name: ci-cd
on:
  push:
    branches: ["main"]
  workflow_dispatch:

env:
  IMAGE_API: ghcr.io/${{ github.repository }}/image-express-api
  IMAGE_WORKER: ghcr.io/${{ github.repository }}/image-processing-worker

jobs:
  # ===========================================================================
  # 1) BUILD & PUSH ‚Äì Publica im√°genes en GHCR (API y Worker)
  # ===========================================================================
  build-and-push:
    name: Build & Push images (GHCR)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4

      - name: üß± Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # -------- API --------
      - name: üè∑Ô∏è Meta (API)
        id: meta_api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_API }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,format=short

      - name: üèóÔ∏è Build & Push (API)
        uses: docker/build-push-action@v6
        with:
          context: ./image-express-api
          file: ./image-express-api/Dockerfile
          push: true
          tags: ${{ steps.meta_api.outputs.tags }}
          labels: ${{ steps.meta_api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # -------- Worker --------
      - name: üè∑Ô∏è Meta (Worker)
        id: meta_worker
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_WORKER }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,format=short

      - name: üèóÔ∏è Build & Push (Worker)
        uses: docker/build-push-action@v6
        with:
          context: ./image-processing-worker
          file: ./image-processing-worker/Dockerfile
          push: true
          tags: ${{ steps.meta_worker.outputs.tags }}
          labels: ${{ steps.meta_worker.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ===========================================================================
  # 2) DEPLOY ‚Äì Copia archivos al VPS y levanta con compose (override prod)
  # ===========================================================================
  deploy:
    name: Deploy to VPS (docker compose)
    needs: build-and-push
    runs-on: ubuntu-latest
    concurrency: deploy-${{ github.ref }}
    steps:
      - name: ‚¨áÔ∏è Checkout
        uses: actions/checkout@v4

      - name: üì¶ Copiar archivos (SCP)
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: |
            docker-compose.yml
            deploy/*
            config/**
            docker-entrypoint-initdb.d/*.js
          target: ${{ secrets.DEPLOY_PATH }}
          overwrite: true
          rm: false
          strip_components: 0

      - name: üöÄ Desplegar (SSH)
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            set -euo pipefail
            cd "${{ secrets.DEPLOY_PATH }}"

            # Verificar que existe el archivo .env con las credenciales
            test -f .env || { echo "‚ùå Falta .env en $PWD"; exit 1; }

            # Crear estructura de directorios necesaria
            if [ ! -d data/traefik/acme ]; then
              echo "‚ö†Ô∏è  No existe data/traefik/acme ‚Äî creando‚Ä¶"
              mkdir -p data/traefik/acme || { echo "‚ùå No pude crear data/traefik/acme"; exit 1; }
            fi
            if [ ! -f data/traefik/acme/acme.json ]; then
              echo "{}" > data/traefik/acme/acme.json || { echo "‚ùå No pude crear acme.json"; exit 1; }
            fi
            chmod 600 data/traefik/acme/acme.json || { echo "‚ùå No pude aplicar chmod 600 a acme.json"; exit 1; }

            # Crear directorios de storage si no existen
            mkdir -p storage/images/{input,output}
            mkdir -p logs

            # =======================================================================
            # DETERMINACI√ìN DEL TAG DE IMAGEN
            # =======================================================================
            # Estrategia de versionado:
            # - Branch 'main': usa tag 'latest' para producci√≥n estable
            # - Otras branches: usa SHA corto del commit (ej: abc1234) para testing
            # 
            # Esto permite:
            # 1. Rollback f√°cil en producci√≥n usando SHA espec√≠ficos
            # 2. Testing de features en desarrollo con tags √∫nicos
            # 3. Identificaci√≥n clara de qu√© versi√≥n est√° desplegada
            # =======================================================================
            
            SHORT_SHA="$(echo "${{ github.sha }}" | cut -c1-7)"
            
            if [ "${{ github.ref_name }}" = "main" ]; then 
              IMAGE_TAG="latest"
              echo "‚úÖ Desplegando a producci√≥n con tag: latest"
            else 
              IMAGE_TAG="$SHORT_SHA"
              echo "üß™ Desplegando branch de desarrollo con tag: $SHORT_SHA"
            fi
            
            export IMAGE_TAG

            # Login a GitHub Container Registry
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Pull de las nuevas im√°genes
            docker compose -f docker-compose.yml -f deploy/docker-compose.prod.yml pull

            # Deploy con zero-downtime (--remove-orphans limpia contenedores hu√©rfanos)
            docker compose -f docker-compose.yml -f deploy/docker-compose.prod.yml up -d --remove-orphans

            # Limpieza de im√°genes antiguas
            docker image prune -f

            # Verificaci√≥n del deploy
            echo "üìä Estado de los servicios:"
            docker compose ps